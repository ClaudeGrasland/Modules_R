[
  {
    "objectID": "data.html#i.-afrique-data",
    "href": "data.html#i.-afrique-data",
    "title": "Données",
    "section": "I. Afrique data",
    "text": "I. Afrique data\nPrésentation des données, source, date… Bla bla bla\n\n Télécharger les données\n\n\n\n\nAffichage de données :\n\n\n\n\n\n\n\n\n\n\n\nDictionnaire des variables :"
  },
  {
    "objectID": "data.html#ii.-gadm-afrique",
    "href": "data.html#ii.-gadm-afrique",
    "title": "Données",
    "section": "II. GADM Afrique",
    "text": "II. GADM Afrique\nPrésentation des données, source, date… Bla bla bla\n\n Télécharger les données\n\n\n\n\nAffichage de données :\n\n\n\n\n\n\n\n\n\n\n\nDictionnaire des variables :"
  },
  {
    "objectID": "data.html#iii.-africapolis",
    "href": "data.html#iii.-africapolis",
    "title": "Données",
    "section": "III. Africapolis",
    "text": "III. Africapolis\nPrésentation des données, source, date… Bla bla bla\n\n Télécharger les données\n\n\n\n\nAffichage d’un échantillon (uniquement Ghana, Bénin et Togo :\n\n\n\n\n\n\n\n\n\n\n\nDictionnaire des variables :"
  },
  {
    "objectID": "data.html#iii.-elevation-bénin",
    "href": "data.html#iii.-elevation-bénin",
    "title": "Données",
    "section": "III. Elevation Bénin",
    "text": "III. Elevation Bénin\nPrésentation des données, source, date… Bla bla bla https://energydata.info/dataset/benin-elevation-2008/resource/55593816-3ef3-45bf-b7f0-7aea16ddaf62\n\n Télécharger les données\n\n\n\n\nAffichage de données :\n\n\n\n\n\n\n\n\n\nCaractèristiques du Raster :\n\n\nclass       : SpatRaster \ndimensions  : 742, 369, 1  (nrow, ncol, nlyr)\nresolution  : 0.008339098, 0.008333169  (x, y)\nextent      : 0.774574, 3.851701, 6.23514, 12.41835  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : elevation.tif \nname        : elevation"
  },
  {
    "objectID": "modules/import.html",
    "href": "modules/import.html",
    "title": "Import",
    "section": "",
    "text": "Import et export de données\n\n\nLes différents types et formats de données pris en charge par R\n\n\n\n\n\n\n26 janv. 2023\n\n\nHugues pecout\n\n\n\n\n\n\n\n\nPackages de données et API\n\n\nQuelques packages forunisseurs de données\n\n\n\n\n\n\nWork in progress\n\n\n\n\n\n\n\n\nExploiter les données OSM\n\n\nRécupérer des données d’OpenStreetMap avec R\n\n\n\n\n\n\nwork in progress\n\n\n\n\n\n\n\n\nInitiation au web scraping\n\n\nCollecter des données du Web avec R (API, scraping…)\n\n\n\n\n\n\nwork in progress\n\n\n\n\n\n\nAucun article correspondant\n\n\n\n\nRevenir à la page d’acceuil des modules"
  },
  {
    "objectID": "modules/geomatique.html",
    "href": "modules/geomatique.html",
    "title": "Géomatique",
    "section": "",
    "text": "Tous les modules\n\n\n\n\n\n\n   \n     \n     \n       Trier par\n       Ordre par défaut\n         \n          Titre\n        \n         \n          Auteur·rice\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nManipulation de données vectorielles\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nManipulation de données Raster\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "modules/cartographie.html",
    "href": "modules/cartographie.html",
    "title": "Cartographie",
    "section": "",
    "text": "Tous les modules\n\n\n\n\n\n\n   \n     \n     \n       Trier par\n       Ordre par défaut\n         \n          Titre\n        \n         \n          Auteur·rice\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nCartographie statique\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nCartographie dynamqiue\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "modules/graphique/package_graph.html",
    "href": "modules/graphique/package_graph.html",
    "title": "Aperçu des packages graphiques",
    "section": "",
    "text": "work in progress"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html",
    "href": "modules/graphique/Rbase_graph.html",
    "title": "Graphique R-base",
    "section": "",
    "text": "Le langage R met à disposition un ensemble de fonctions pour la représentation graphique via le package pré-installé graphics . Bien que l’on préférera des packages spécialisés et plus complets comme ggplot2 pour créer de jolis graphiques personnalisés, les fonctions R-base de représentation peuvent être très utiles en matière d’exploration de données."
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#fonctions-graphiques",
    "href": "modules/graphique/Rbase_graph.html#fonctions-graphiques",
    "title": "Graphique R-base",
    "section": "Fonctions graphiques",
    "text": "Fonctions graphiques\nLes fonctions graphiques peuvent être classées en trois catégories :\nI. Les fonctions permettant de créer de nouveaux graphiques :\n\nplot()\nbarplot()\nstripchart()\nhist()\nboxplot()\ncurve()\netc….\n\nII. les fonctions permettant d’ajouter de l’information à un graphique existant :\n\nlegend()\ntitle()\ndensity()\npoints()\nlines()\ntext()\netc…\n\nIII. Les fonctions utilisées pour fixer et contrôler des paramètres graphiques généraux (disposition des figures, marges, axes, police, etc… :\n\npar()\nlayout()\n\n\n\n\nFonction plot()\nLa fonction la plus couramment utilisée pour produire des graphiques dans R est la fonction plot(). plot() est une fonction générique dont le comportement s’adapte automatiquement à la nature de ses arguments. Il y a deux syntaxes possibles pour cette fonction :\n\nsyntaxe classique: plot(x = varX, y = varY)\nsyntaxe à base de formule: plot(varY ~ varX),\n\noù varX et varY sont les noms des variables à mettre dans l’axe des x et l’axe des y, respectivement. L’expression varY ~ varX est un exemple de ce que R appelle formula (formule). Dans cette expression varY désigne la variable dépendante (à expliquer, càd., celui dont on cherche à étudier les variations) et varX la variable indépendante (explicative). Si vous tapez methods(plot), vous allez voir, dans liste des méthodes, la fonction plot.formula(). C’est cette dernière qui est en réalité appelée à chaque fois qu’une formule est introduite comme argument.\n\n\nCode\n# les données\nx <- seq(-pi, pi, 0.1)\ny <- sin(x)\n\nplot(x, y)   # format classique\n\n\n\n\n\nCode\nplot(y ~ x)  # formule ---> plot.formula\n\n\n\n\n\nAvec la syntaxe “formule”, la fonction plot() accepte l’argument data (voir le Help de plot.formula()) qui permet de simplifier davantage la syntaxe lorsqu’il s’agit de données stockées dans des data frames. Ainsi les deux lignes de codes suivantes sont équivalentes et produisent le même graphique que ci-dessus.\n\n\nCode\ndt <- data.frame(z = x, w = y)\nplot(dt$w ~ dt$z)\nplot(w ~ z, data = dt)\n\n\nLa fonction plot() accepte une multitude d’arguments qui permettent de façonner les graphiques (voir le Help pour plus de détails).\n\n\nCode\nplot(w ~ z, data = dt,\n  type = \"o\", # type de tracé: points (\"p\"), lignes (\"l\"), les deux (\"b\" ou \"o\"), ...\n  col = \"blue\", # couleur, tapez `colours()` pour la liste complète\n  pch = 4, # type de symboles, un chiffre entre 0 et 25, tapez `?points`\n  cex = 0.5, # taille des symboles\n  lty = 3, # type de lignes, un chiffre entre 1 et 6\n  lwd = 1.2, # taille de lignes\n  xlim = c(-2.5, 2.5), # limites de l'axe des x\n  ylim = c(-1.5, 1.5), # limites de l'axe des y)\n  xlab = \"La variable z\", # titre pour l'axe des x\n  ylab = \"Le sinus  de z\", # titre pour l'axe des y\n  main = \"La fonction sinus entre -pi et pi\" # titre général pour le graphique\n)"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#représenter-des-variables",
    "href": "modules/graphique/Rbase_graph.html#représenter-des-variables",
    "title": "Graphique R-base",
    "section": "Représenter des variables",
    "text": "Représenter des variables\n\nVariable quantitative\n\n\nCode\n# gauche supérieur\nstripchart(mpg$displ, xlab = \"displ\", pch = 16)\n# droite supérieur\nstripchart(mpg$displ, xlab = \"displ\", method = \"stack\", pch = 16)\n# gauche inférieur\nstripchart(mpg$displ, xlab = \"displ\", method = \"jitter\", pch = 16)\n# droite inférieur\nstripchart(mpg$displ, ylab = \"displ\", method = \"jitter\", vertical = TRUE, pch = \"+\")\n\nplot(mpg$drv)   #---> barplot()\nbarplot(mpg$drv)\n\n# Pour la distribution\nhist(mpg$displ)\nhist(mpg$displ, freq = FALSE)\ndensity(mpg$displ)\n\n\n\n\nDeux variables quantitatives\n\n\nCode\nplot(hwy ~ displ, data = mpg, pch = 16)\n\n\n\n\nVariale qualitative\n\n\n\n\n\nDeux variables qualitatives\n\n\nCode\nplot()\nbarplot()\n\n\n\n\nVaribales qualitatives et quantitatives\n\n\nCode\nstripchart(hwy ~ trans, data = mpg, vertical = TRUE, pch = 16, metho = \"jitter\")\n\nboxplot(hwy ~ trans, data = mpg)\n\nplot()\n\nboxplot(hwy ~ trans, data = mpg)\nstripchart(hwy ~ trans, data = mpg, vertical = TRUE, pch = 16, metho = \"jitter\", add = TRUE)\n\nboxplot(hwy ~ trans + drv, data = mpg)"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#tracer-une-fonction",
    "href": "modules/graphique/Rbase_graph.html#tracer-une-fonction",
    "title": "Graphique R-base",
    "section": "Tracer une fonction",
    "text": "Tracer une fonction\n\n\nCode\ncurve()\ncurve(x^2, from = 0, to = 20, col = \"red\", lty = 1, ylab = \"y\")\ncurve(x^(2.5), from = 0, to = 20, col = \"gray\", lty = 2, add = TRUE)\ncurve(x^(3), from = 0, to = 20, col = \"blue\", lty = 3, add = TRUE)\nlegend(\"topright\", title = \"Function\", legend = c(\"x^2\", \"x^2.5\", \"x^3\"), col = c(\"red\", \"gray\", \"blue\"), lty = 1:3, bty = \"n\", inset = c(0.2, 0))"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#exporter-un-graphique",
    "href": "modules/graphique/Rbase_graph.html#exporter-un-graphique",
    "title": "Graphique R-base",
    "section": "Exporter un graphique",
    "text": "Exporter un graphique\nUn graphique crée dans RStudio est affiché par défaut dans l’onglet Plots. Vous pouvez utiliser cet onglet pour zoomer sur un graphique en cliquant sur le bouton Zoom. Vous pouvez aussi enregistrer le graphique en cliquant sur le bouton Export.\nPour sauvegarder un graphique R (tel que vous le visualisez sur votre écran) en format PDF, vous pouvez aussi exécuter le code suivant en remplaçant filename par le le nom que vous voulez. Le fichier ainsi créé sera enregistré dans votre répertoire de travail R.\n\n\nCode\ndev.print(pdf, \"filename.pdf\") # <-- remplacez 'filename' (gardez l'extension pdf)"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#exercice",
    "href": "modules/graphique/Rbase_graph.html#exercice",
    "title": "Graphique R-base",
    "section": " Exercice",
    "text": "Exercice\n\n\n\n1. Créez un projet Rstudio\nFile/New Project/New Directory…"
  },
  {
    "objectID": "modules/statistique.html",
    "href": "modules/statistique.html",
    "title": "Statistique",
    "section": "",
    "text": "Trier par\n       Ordre par défaut\n         \n          Titre\n        \n         \n          Auteur·rice\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nStatistique descriptive univariée\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nStatistique descriptive bivariée\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nStatistique descriptive multivariée\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "modules/manipulation.html",
    "href": "modules/manipulation.html",
    "title": "Manipulation",
    "section": "",
    "text": "Tous les modules\n\n\n\n\n\n\n   \n     \n     \n       Trier par\n       Ordre par défaut\n         \n          Titre\n        \n         \n          Auteur·rice\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nUtilisation du tidyverse\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nManipulation en R-base\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nUtilisation de data.table\n\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "modules/graphique.html",
    "href": "modules/graphique.html",
    "title": "Graphique",
    "section": "",
    "text": "Graphique R-base\n\n\nRepresentations graphiques avec les fonctions primitives\n\n\n\n\n\n\n26 janv. 2023\n\n\nHugues pecout\n\n\n\n\n\n\n\n\nGraphique avec ggplot2\n\n\nRepresentations graphiques avec ggplot2\n\n\n\n\n\n\n24 janv. 2023\n\n\nHugues pecout\n\n\n\n\n\n\n\n\nAperçu des packages graphiques\n\n\nVue d’ensemble des packages disponibles pour la représentation graphique\n\n\n\n\n\n\n24 janv. 2023\n\n\nHugues pecout\n\n\n\n\n\n\nAucun article correspondant\n\n\n\n\nRevenir à la page d’acceuil des modules"
  },
  {
    "objectID": "modules/import/import.html",
    "href": "modules/import/import.html",
    "title": "Import et export de données",
    "section": "",
    "text": "De nombreuses de fonctions (primitives ou non) permettent d’importer et d’exporter des données de différents formats."
  },
  {
    "objectID": "modules/import/import.html#tableau-de-données",
    "href": "modules/import/import.html#tableau-de-données",
    "title": "Import et export de données",
    "section": "Tableau de données",
    "text": "Tableau de données\n\nFichier texte simple\nUn fichier texte simple (ou fichier texte brut) est un fichier dont le contenu représente uniquement une suite de caractères. Il peut s’ouvrir avec n’importe quel éditeur de texte et utilise nécessairement une forme particulière de codage des caractères.\nPlusieurs fonctions primitives permettent d’importer et d’exporter des fichiers texte simples, comme les fichiers csv, txt , tsv…\n\nImport\n\nread.delim() : fichiers délimités par un symbole quelconque et “.” en séparateur décimal\nread.delim2() : fichiers délimités par un symbole quelconque et “,” en séparateur décimal\nread.table() : pour des fichiers texte délimités par des espaces\n\nread.csv() : pour des fichiers texte délimités par des virgules (format csv)\nread.csv2() : pour des fichiers texte délimités par des points-virgules (format csv français)\n\nPour que l’import de données s’effectue correctement, il est parfois nécessaire de renseigner plusieurs arguments, comme par exemple :\nheader = valeur logique qui indique si la première ligne contient les noms des variables. sep = indique le caractère utilisé comme séparateur de champ (ex : “;”) encoding = Chaîne de caractère qui précise l’encodage utilisé pour le fichier (ex : “UTF-8”).\n\n\n\n\n\n\nImportant\n\n\n\nN’oubliez pas d’assigner le résultat dans un objet pour garder en mémoire vos données importées.\n\n\n\n# Exemple d'utilisation de read.table()\nmon_tableau  <- read.table(file = \"../data/DEV_AFRICA_2018/afrika_don_meta.csv\", \n                           header = TRUE,\n                           sep= \";\",\n                           encoding = \"UTF-8\")\n\n\n# Le tableau importé est stocké dans un objet data.frame\nclass(mon_tableau)\n\n[1] \"data.frame\"\n\n\n\n\nExport\nDes fonctions primitives permettent également d’exporter votre tableau de données vers différents format texte.\n\nwrite.table() : pour tous les types de formats texte simple (séparateur à renseigner)\nwrite.csv() : pour exporter en csv (séparateur virgule)\nwrite.csv2() : pour exporter en csv (séparateur points-virgules)\n\n\n\nVoir l’exemple\n# Exemple write.table()\nwrite.table(x = mon_tableau, \n            file = \"../data/tableau.txt\", \n            sep = \"\\t\", col.names = TRUE, \n            fileEncoding = \"UTF-8\")\n              \n# Exemple write.csv()\nwrite.csv(x = mon_tableau, file = \"../data/tableau.csv\")\n\n\n\n\n\n\n\nExcel\nIl est parfois nécessaire d’importer des tableaux de données stockées dans un format propriétaire, comme par exemple Excel (xls, xlsx) ou SAS. Plusieurs packages vous permettent d’importer ce genre de format, et même d’exporter vos données dans ce type de format.\n\nImport\nVous pouvez par exemple importer un fichier Excel avec le package readxl.\n\ninstall.packages(\"readxl\")\n\n\n\n\n\n\n\nImportant\n\n\n\nLe packages readxl fait partie de l’écosystème tidyverse (cf. module x). Pour cette raison, le tableau importé est mis en mémoire dans un objet tibble et non dataframe. Il s’agit de deux objets très semblables mais pas identiques. Pour convertir un tibble en dataframe, vous pouvez utiliser la fonction as.data.frame().\n\n\n\nlibrary(readxl)\nmon_tableau <- read_excel(path = \"../data/DEV_AFRICA_2018/afrika_don.xls\", \n                          sheet = \"afrika_meta\", \n                          skip = 0,\n                          col_names = TRUE)\n\n# Le tableau importé est stocké dans un objet data.frame\nclass(mon_tableau)\n\n[1] \"tbl_df\"     \"tbl\"        \"data.frame\"\n\n\n\n\nExport\nPour exporter un dataframe (ou tibble) dans un fichier au format Excel, vous pouvez utiliser le package openxlsx et sa fonction write.xlsx().\n\ninstall.packages(\"openxlsx\")\n\n\n\n\n\n\n\nImportant\n\n\n\nLe packages openxlsx permet uniquement de lire et écrire les fichiers Excel comportant l’extension .xlsx.\n\n\n\n\nVoir l’exemple\nlibrary(openxlsx)\nwrite.xlsx(x = mon_tableau, file = \"../data/DEV_AFRICA_2018/afrika_don.xlsx\")\n\n\n\n\n\n\n\nSAS\nLe package haven permet de gérer des fichiers propriètaires de différents formats : SAS, SPSS, Stata, dbf…\n\ninstall.packages(\"haven\")\n\n\n\n\n\n\n\nImportant\n\n\n\nTout comme readxl, ce package fait partie de l’écosystème tidyverse (cf. module x). Le tableau importé est mis en mémoire dans un objet tibble et non dataframe. Vous pouvez utiliser la fonction as.data.frame() pour le convertir.\n\n\n\nImport\n\n\nVoir l’exemple\nlibrary(haven)\nmon_tableau  <- read_sas(data_file = \"../data/data_sas.sas7bdat\")\n\n\n\n\nExport\n\n\nVoir l’exemple\nlibrary(haven)\nwrite_sas(data = mon_tableau, path = \"../data/mon_tableau_sas.sas7bdat\")\n\n\n\n\n\n\n\nSPSS\nVous pouvez utiliser le package haven qui permet la lecture et l’écriture de fichier de données SAS.\n\nImport\n\n\nVoir l’exemple\nlibrary(haven)\nmon_tableau  <- read_sav(file =  \"../data/data_spss.sav\")\n\n\n\n\nExport\n\n\nVoir l’exemple\nlibrary(haven)\nwrite_sav(data = mon_tableau, path =  \"../data/mon_tableau_spss.sav\")\n\n\n\n\n\n\n\nStata\nVous pouvez utiliser le package haven qui permet la lecture et l’écriture de fichier de données Stata.\n\nImport\n\n\nVoir l’exemple\nlibrary(haven)\nmon_tableau  <- read_stata(file =  \"../data/data_stata.dta\")\n\n\n\n\nExport\n\n\nVoir l’exemple\nlibrary(haven)\nwrite_dta(data = mon_tableau, path =  \"../data/mon_tableau_stata.dta\")"
  },
  {
    "objectID": "modules/import/import.html#couche-géographique",
    "href": "modules/import/import.html#couche-géographique",
    "title": "Import et export de données",
    "section": "Couche géographique",
    "text": "Couche géographique\n\nVecteur\nLe package sf permet de lire les différents formats de couche géographique vectorielle (ESRI Shapefile, GeoJSON, Keyhole Markup Language, GeoPackage…). Pour cela, ce package interface avec la librairie système GDAL. Les SIG fonctionnent de la même façon !\n\ninstall.packages(\"sf\")\n\n\n\n\n\n\n\nNote\n\n\n\nL’installation du package sf demande un prérequis. La librairie système GDAL doit être installée sur votre machine. Il est parfois nécessaire de la faire soi-même sur certains système d’exploitation comme GNU/Linux.\n\n\n\nImport\n\nlibrary(sf)\nmap_africa <- st_read(\"../data/GADM_AFRICA_2020/afrika_map.shp\",  quiet = TRUE)\n\nclass(map_africa)\n\n[1] \"sf\"         \"data.frame\"\n\n\n\n\n\n\n\n\nImportant\n\n\n\nUne couche géographique importée via la fonction st_read() du package sf est mise en mémoire dans un objet sf (simple feature). Il s’agit en quelque sorte d’un dataframe ou chaque individu est associé à une géométrie.\n\n\n\n\nExport\nLa fonction st_write() permet d’enregistrer un objet sf sur sa machine, dans le format que l’on souhaite.\n\n\nVoir les exemples\nlibrary(sf)\n\n# Enregistrement en format ESRI Shapefile\nst_write(obj = map_africa, \n         dsn = \"../data/map_africa.shp\", \n         layer_options = \"ENCODING=UTF-8\")\n\n\n# Enregistrement en format GeoPackage\nst_write(obj = map_africa, \n         dsn = \"../data/map_africa.gpkg\", \n         layer = \"pays\")\n\n\n\n\n\n\n\nRaster\nLe package terra permet aussi de lire et d’écrire des données géographiques vectorielles (comme sf) mais sa valeur ajoutée se situe au niveau de la manipulation de données raster.\n\ninstall.packages(\"terra\")\n\n\nImport\nPour importer des données Raster, vous pouvez utiliser la fonction rast().\n\n\n\n\n\n\nImportant\n\n\n\nUn Raster importé via la fonction rast() du package terra est mis en mémoire dans un objet SpatRaster.\n\n\n\nlibrary(terra)\nElevation_Benin <- rast(\"../data/elevation.tif\") \n\nElevation_Benin\n\nclass       : SpatRaster \ndimensions  : 742, 369, 1  (nrow, ncol, nlyr)\nresolution  : 0.008339098, 0.008333169  (x, y)\nextent      : 0.774574, 3.851701, 6.23514, 12.41835  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsource      : elevation.tif \nname        : elevation \n\n\n\n\nExport\nLa fonction writeRaster() permet d’enregistrer un objet SpatRaster sur sa machine, dans le format que l’on souhaite.\n\n\nVoir l’exemple\nlibrary(terra)\nwriteRaster(x = Elevation_Benin, filename = \"../data/Benin_Elevation.tif\")"
  },
  {
    "objectID": "modules/import/import.html#image",
    "href": "modules/import/import.html#image",
    "title": "Import et export de données",
    "section": "Image",
    "text": "Image\n\nImport\nPour importer des images, le package pnget jpeg, pré-installés avec le language R vous permet d’importer des images.\n\nPNG\n\n\nVoir l’exemple\nlibrary(png)\nmon_image_png <- readPNG(\"../img/map.png\")\n\n\n\n\nJPEG\n\n\nVoir l’exemple\nlibrary(jpeg)\nmon_image_jpg <- readJPEG(\"../img/wip.jpg\")\n\n\n\n\n\nExport\nIl est également possible d’exporter les sorties graphiques en format image avec les fonctions primitives suivantes :\n\nbmp()\njpeg()\npng()\ntiff()\n\nCes fonctions doivent être utilisées avec la fonction dev.off(). Exemple :\n\n\nVoir l’exemple\n# Ouverture de la création de l'image\npng(filename = \"../img/mon_image.jpg\")\n\n# Création de la représentation graphique souhaitée\nplot(1:10)\n\n# Fermeture (enregistrement) de l'image png\ndev.off()\n\n\n\n\n\n\n\n\nImportant\n\n\n\nLa fonction dev.off() permet de clôturer la représentation graphique et d’enregistrer l’image. Si aucun dev.off() n’est exécuté à la suite de ces fonctions d’export, votre fenêtre graphique restera figée, et inutilisable.\n\n\nIl est également possible d’exporter vos représentations graphiques dans un format vectoriel, qui permet leur retouche avec des logiciel de DAO (Inkscape, Adobe Illustrator…). Les fonction pour réaliser cela sont :\n\npdf()\nsvg()\n\nL’utilisation de ces fonctions primitives est similaire à l’export d’images matricielles. Exemple :\n\n\nVoir l’exemple\n# Ouverture de la création de l'image\npdf(file = \"../img/mon_image.pdf\")\n\n# Création de la représentation graphique souhaitée\nplot(1:10)\n\n# Fermeture (enregistrement) du pdf\ndev.off()"
  },
  {
    "objectID": "modules/import/import.html#exercice",
    "href": "modules/import/import.html#exercice",
    "title": "Import et export de données",
    "section": " Exercice",
    "text": "Exercice\n\n\n\n1. Créez un projet Rstudio\nFile/New Project/New Directory…\n\n\n2. Téléchargez les données suivantes :\n\n\n\n\n\n\n\nIntitulé\nTéléchargement\n\n\n\n\nDonnées pays africains (UN-CEPII)\n Download\n\n\nFond de carte Afrique (GADM 2020)\n Download\n\n\nRaster délévation du Bénin (???)\n Download\n\n\n\n\n\n3. Placez les données (décompressées) dans le répertoire de votre projet, de la façon suivante :\n\n\n\n\n\n\n\n\n\n\n\n4. Créez un script R à la racine de votre projet Rstudio\nFile/New File/R script\n\n\n5. Importer les fichiers suivants en utilisant les fonctions adéquates :\n\ndata/DEV_AFRIA_2018/afrika_don.csv\n\ndata/DEV_AFRICA_2018/afrika_don.xls (1er onglet)\n\ndata/GADM_AFRICA_2020/afrika_map.shp\n\ndata/elevation.tif\n\n\n\n\nUn peu d’aide ?\n# Pour importer un fichier csv (afrika_don.csv)\nread.csv()\nread.csv2()\n\n# Pour importer un fichier Excel (afrika_don.xls)\nlibrary(readxl)\nread_excel()\n\n# Pour importer un fichier ESRI Shapefile (afrika_map.shp)\nlibrary(sf)\nst_read()\n\n\n\n\nCorrection\n# Import du fichier csv \"afrika_don.csv\"\ndata_from_csv <- read.csv2(file = \"data/DEV_AFRICA_2018/afrika_don.csv\")\n\n# Import du fichier xls \"afrika_don.xls\"\nlibrary(readxl)\ndata_from_xls <- read_excel(path = \"data/DEV_AFRICA_2018/afrika_don.xls\")\n\n# Importer du fichier shp \"afrika_map.shp\"\nlibrary(sf)\ndata_from_shp <- st_read(\"data/GADM_AFRICA_2020/afrika_map.shp\",  quiet = TRUE)"
  },
  {
    "objectID": "modules/import/osm.html",
    "href": "modules/import/osm.html",
    "title": "Exploiter les données OSM",
    "section": "",
    "text": "Work in progress"
  },
  {
    "objectID": "modules/import/scraping.html",
    "href": "modules/import/scraping.html",
    "title": "Initiation au web scraping",
    "section": "",
    "text": "Work in progress"
  },
  {
    "objectID": "modules/notebook.html",
    "href": "modules/notebook.html",
    "title": "Notebook",
    "section": "",
    "text": "Tous les modules\n\n\n\n\n\n\n   \n     \n     \n       Trier par\n       Ordre par défaut\n         \n          Titre\n        \n         \n          Auteur·rice\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\nExemple Quarto\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nLa programmation lettrée\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\nLes notebooks (exécutables)\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "modules.html",
    "href": "modules.html",
    "title": "Modules thématiques",
    "section": "",
    "text": "Import\n\n\nImport, collecte (API) et export de données\n\n\n\n\n\n\n\n\n\n\n\n\n\nManipulation\n\n\nGestion & traitement de données\n\n\n\n\n\n\n\n\n\n\n\n\n\nStatistique\n\n\nStat. descriptive uni, bi et multivariée\n\n\n\n\n\n\n\n\n\n\n\n\n\nGraphique\n\n\nReprésentation graphique\n\n\n\n\n\n\n\n\n\n\n\n\n\nGéomatique\n\n\nTraitement données vecteur et raster\n\n\n\n\n\n\n\n\n\n\n\n\n\nCartographie\n\n\nCartographie thématique\n\n\n\n\n\n\n\n\n\n\n\n\n\nNotebook\n\n\nConstruction de document combinant du texte et du code\n\n\n\n\n\n\n\nAucun article correspondant"
  },
  {
    "objectID": "presentation.html",
    "href": "presentation.html",
    "title": "Introduction",
    "section": "",
    "text": "Les différents modules thématiques peuvent être utilisés indépendamment les uns des autres. Il est néanmoins nécessaire de connaître les bases du langage R (objets, opérateurs, fonctions…) pour comprendre les différents cours et exercices proposés.\nSi vous êtes débutant.e, plusieurs supports libres et gratuits d’initiation à R sont indiqués dans les ressources annexes. Vous pouvez également consulter ces deux supports de communication utilisés pour introduire au langage R :\n\n\n\n\n\nConsulter en plein écran\n\n\n\n\n\n\n\nConsulter en plein écran\n\n\n\n\n\n\nLes modules thématiques\nLe contenu de TIG’R est organisé en sept modules thématiques :\n\nImport de données (Import, collecte (API) et export de données)\nManipulation de données (gestion & traitement de données)\nStatistique descriptives (uni, bi et multivariée)\nReprésentation graphique (R-base & ggplot2)\nGéomatique (traitement des données vectorielles et raster)\nCartographie thématique (statique et interactive\nNotebook (Production de document combinant du texte et du code)\n\n\n\n\n\n\n\nNote\n\n\n\nChaque module comprend au moins un cours d’introduction et un exercice appliqué.\n\n\n\n\nLes données\nLes différents jeux de données utilisés dans les modules sont présentés et mis à disposition sur cette page.\n\n\nLes packages\nAfin de maximiser la reproductibilité des traitements présentés, les différents modules de formation tentent de minimiser les dépendances à des packages. De plus, les différents packages utilisés sont des références dans la communauté R et laisser présager une certaine stabilité du code présenté.\nLes packages utilisés dans les différents modules thématiques sont :\n\nreadxl\nopenxlsx\nhaven\ndplyr\nlubridate\nFactoMineR\nggplot2\nsf\nterra\nmapsf\nrmarkdown\nknitr\n\n\n# Liste de package à installer\npackages <- c(\"readxl\", \"openxlsx\", \"haven\",\n              \"dplyr\", \"lubridate\", \"stringr\",\n              \"ggplot2\",  \"FactoMineR\", \"sf\", \n              \"terra\", \"mapsf\", \"rmarkdown\", \"knitr\")\n\n\n# Détéction de package à installer\nmissing_packages <- packages [!(packages  %in% installed.packages()[,\"Package\"])]\n\n# Installation des packages manquants\nif(length(missing_packages)) install.packages(missing_packages)\n\n\n\nConditions d’utilisation\nLe contenu de ce site web (support de cours et exercice inclus) est soumis à la Licence ouverte V2.0 d’Etalab. Le « Réutilisateur » est libre de réutiliser l’ « Information » :\n\nde la reproduire, la copier,\n\nde l’adapter, la modifier, l’extraire et la transformer, pour créer des « Informations dérivées », des produits ou des services,\n\nde la communiquer, la diffuser, la redistribuer, la publier et la transmettre,\n\nde l’exploiter à titre commercial, par exemple en la combinant avec d’autres informations, ou en l’incluant dans son propre produit ou application.\n\nSous réserve de :\n\nmentionner la paternité de l’ « Information » : sa source (cf. citation et la date de dernière mise à jour de l’ « Information » réutilisée.\n\n\n\nCitation TIG’R\n\n\nPecout H., et Dansou J. 2023. « TIG’R :  Traitement de l’information géographique avec R ». 2023. https://ee2023.netlify.app/."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "",
    "section": "",
    "text": "TIG’R est une ressource d’apprentissage pour le traitement de l’information géographique avec R. Ce site a été crée dans le cadre de l’école thématique Méthodes et outils de sciences territoriales organisée par le Collègue Internationnal des Sciences Territoirales et qui s’est déroulée au à Ouidah (Bénin) en Mars 2023.\nCe site contient l’ensemble des supports de cours et exercices reproductibles utilisés pour les modules de formation à R. Ces modules couvrent succinctement l’ensemble de la chaîne de traitement de données géographiques avec R.\nCette ressource est soumise à la Licence ouverte V2.0 d’Etalab. N’hésitez pas à la réutiliser !"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#fonctions-graphiques-primitives",
    "href": "modules/graphique/Rbase_graph.html#fonctions-graphiques-primitives",
    "title": "Graphique de base",
    "section": "Fonctions graphiques primitives",
    "text": "Fonctions graphiques primitives\nLes fonctions graphiques peuvent être classées en trois catégories :\nI. Les fonctions permettant de créer de nouveaux graphiques :\n\nplot()\nbarplot()\nstripchart()\nhist()\nboxplot()\ncurve()\netc….\n\nII. les fonctions permettant d’ajouter de l’information à un graphique existant :\n\nlegend()\ntitle()\ndensity()\npoints()\nlines()\ntext()\netc…\n\nIII. Les fonctions utilisées pour fixer et contrôler des paramètres graphiques généraux (disposition des figures, marges, axes, police, etc… :\n\npar()\nlayout()\n\n\n\n\nFonction plot()\nLa fonction la plus couramment utilisée pour produire des graphiques dans R est la fonction plot(). plot() est une fonction générique dont le comportement s’adapte automatiquement à la nature de ses arguments. Il y a deux syntaxes possibles pour cette fonction :\n\nsyntaxe classique: plot(x = varX, y = varY)\nsyntaxe à base de formule: plot(varY ~ varX),\n\noù varX et varY sont les noms des variables à mettre dans l’axe des x et l’axe des y, respectivement. L’expression varY ~ varX est un exemple de ce que R appelle formula (formule). Dans cette expression varY désigne la variable dépendante (à expliquer, càd., celui dont on cherche à étudier les variations) et varX la variable indépendante (explicative). Si vous tapez methods(plot), vous allez voir, dans liste des méthodes, la fonction plot.formula(). C’est cette dernière qui est en réalité appelée à chaque fois qu’une formule est introduite comme argument.\n\n\nCode\n# les données\nx <- seq(-pi, pi, 0.1)\ny <- sin(x)\n\nplot(x, y)   # format classique\n\n\n\n\n\nCode\nplot(y ~ x)  # formule ---> plot.formula\n\n\n\n\n\nAvec la syntaxe “formule”, la fonction plot() accepte l’argument data (voir le Help de plot.formula()) qui permet de simplifier davantage la syntaxe lorsqu’il s’agit de données stockées dans des data frames. Ainsi les deux lignes de codes suivantes sont équivalentes et produisent le même graphique que ci-dessus.\n\n\nCode\ndt <- data.frame(z = x, w = y)\nplot(dt$w ~ dt$z)\nplot(w ~ z, data = dt)\n\n\nLa fonction plot() accepte une multitude d’arguments qui permettent de façonner les graphiques (voir le Help pour plus de détails).\n\n\nCode\nplot(w ~ z, data = dt,\n  type = \"o\", # type de tracé: points (\"p\"), lignes (\"l\"), les deux (\"b\" ou \"o\"), ...\n  col = \"blue\", # couleur, tapez `colours()` pour la liste complète\n  pch = 4, # type de symboles, un chiffre entre 0 et 25, tapez `?points`\n  cex = 0.5, # taille des symboles\n  lty = 3, # type de lignes, un chiffre entre 1 et 6\n  lwd = 1.2, # taille de lignes\n  xlim = c(-2.5, 2.5), # limites de l'axe des x\n  ylim = c(-1.5, 1.5), # limites de l'axe des y)\n  xlab = \"La variable z\", # titre pour l'axe des x\n  ylab = \"Le sinus  de z\", # titre pour l'axe des y\n  main = \"La fonction sinus entre -pi et pi\" # titre général pour le graphique\n)"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#principales-fonctions",
    "href": "modules/graphique/Rbase_graph.html#principales-fonctions",
    "title": "Graphique R-base",
    "section": "Principales fonctions",
    "text": "Principales fonctions\n\n3 types de fonction\nLes fonctions graphiques peuvent être classées en trois catégories :\nI. Les fonctions permettant de créer différents types de graphiques :\n\nplot()\nbarplot()\nstripchart()\nhist()\nboxplot()\ncurve()\netc….\n\nII. les fonctions permettant d’ajouter de l’information à un graphique existant :\n\nlegend()\ntitle()\ndensity()\npoints()\nlines()\nabline()\ntext()\netc…\n\nIII. Les fonctions utilisées pour fixer et contrôler des paramètres graphiques généraux :\n\npar()\nlayout()\n\n\n\n\n\nLa fonction plot()\nLa fonction primitive de représentation graphique la plus couramment utilisée est la fonction plot(). Il s’agit d’une fonction générique dont le comportement s’adapte automatiquement à la nature de ses arguments.\nDeux syntaxes sont possibles pour utiliser cette fonction :\n\nClassique :\n\n\nx <- seq(-pi, pi, 0.1)\ny <- sin(x)\n\n\nplot(x, y) \n\n\n\n\n\nsyntaxe “formule” :\n\n\nplot(y ~ x)        \n\n\n\n\nDans l’expression y ~ x, y désigne la variable dépendante (à expliquer) et varX la variable indépendante (explicative).\nLa fonction plot() accepte une multitude d’arguments qui permettent de façonner les graphiques (voir le Help pour plus de détails).\n\nplot(y ~ x, \n  type = \"o\", # type de tracé: points (\"p\"), lignes (\"l\"), les deux (\"b\" ou \"o\"), ...\n  col = \"red\", # couleur, tapez `colours()` pour la liste complète\n  pch = 20, # type de symboles, un chiffre entre 0 et 25, tapez `?points`\n  cex = 1.1, # taille des symboles\n  lty = 1, # type de lignes, un chiffre entre 1 et 6\n  lwd = 1.4, # taille de lignes\n  xlim = c(-2.5, 2.5), # limites de l'axe des x\n  ylim = c(-1.5, 1.5), # limites de l'axe des y)\n  xlab = \"La variable x\", # titre pour l'axe des x\n  ylab = \"Le sinus  de x\", # titre pour l'axe des y\n  main = \"La fonction sinus entre -pi et pi\" # titre général pour le graphique\n) \n\n\n\n\n\n\n\n\nAjout d’éléménts\nUne fois le graphique construit, plusieurs fonctions primitives vous permettre d’ajouter différents éléments. Exemple :\n\nplot(y ~ x, \n  type = \"o\", # type de tracé: points (\"p\"), lignes (\"l\"), les deux (\"b\" ou \"o\"), ...\n  col = \"red\", # couleur, tapez `colours()` pour la liste complète\n  pch = 20, # type de symboles, un chiffre entre 0 et 25, tapez `?points`\n  cex = 1.1, # taille des symboles\n  lty = 1, # type de lignes, un chiffre entre 1 et 6\n  lwd = 1.4, # taille de lignes\n  xlim = c(-2.5, 2.5), # limites de l'axe des x\n  ylim = c(-1.5, 1.5), # limites de l'axe des y)\n  xlab = \"La variable x\", # titre pour l'axe des x\n  ylab = \"Le sinus  de x\") # titre pour l'axe des y) \n\n\n# Ajout d'une LEGENDE\nlegend(x = 0.9, # Emplacement de la légende (coin haut gauche)\n       y = -1.1, # Emplacement de la légende (coin haut gauche)\n       legend = \"Fonction sinus entre -pi et pi\", \n       bg = \"lightgoldenrod\",\n       col = \"red\",\n       pch = 20,\n       cex = 0.7, # Taille de lé lagende\n       lty = 1, \n       lwd = 1.4)\n\n# Ajout d'une LIGNE (horizontale)\nabline(h = 0, # Coupe l'axe des y à cette valeur \n       lty = 2, # Type de ligne\n       lwd = 0.5, # épaisseur\n       col = \"grey50\")\n\n# Ajout d'un POINT\npoints(x = -0, \n       y = 0, \n       col = \"red4\", \n       pch = 20,# Type de symbol\n       cex = 4)\n\n# Ajout de TEXTE\ntext(\"x = 0 = y\", # Texte à afficher\n     x = 0.4, # Emplacement du texte (centre)\n     y = -0.16, # Emplacement du texte (centre)  \n     col = \"red4\")     \n       \n# Ajout d'un TITRE\ntitle(\"Titre de mon graphique\", \n      cex.main = 1.2,  \n      font.main= 4, \n      col.main= \"red4\")\n\n\n\n\n\n\n\n\nFenêtre graphique\nDeux fonctions (par() et layout()) permettent de gérer les paramètres graphiques (disposition figures, marges, axes, police…) :\nExemple d’utilisation de la fonction par() qui contient un grand nombre d’arguments possibles (cf. ?par) :\n\npar(bg = \"royalblue1\", # Couleur de fond\n    col= \"white\",      # couleur du graphique\n    mfrow = c(2,2),    # Fenêtre découper en deux lignes / deux colonnes (4 graphiques)\n    mar = c(5,3,4,1))  # Gestion des marges pour chaque graphique (B,L,T,R)\n\n\nplot(x = log(1:10), y = 10:1, main = \"plot 1\")\n\nplot(x = exp(1:10), y = log(1:10), main = \"plot 2\")\n\nplot(x = sin(1:10), y = 1:10, main = \"plot 3\")\n\nplot(x = 1:10, y = exp(1:10), main = \"plot 4\")\n\n\n\n\nlayout() propose moins d’arguments mais permet un meilleur ajustement de la disposition des figures. Pour cela, il est nécessaire de construire une matrice pour indiquer la position et l’espace de chaque graphique ajouté. Exemple :\n\nmatrix(c(1,1,1,0,2,2,3,3,0),  3,  3,  byrow = TRUE)\n\n     [,1] [,2] [,3]\n[1,]    1    1    1\n[2,]    0    2    2\n[3,]    3    3    0\n\n\nAvec la matrice ci-dessus, la fenêtre graphique sera paramétrée pour contenir trois graphiques. Le graphique 1 occupera toute la première ligne. le graphique deux occupera uniquement les deux dernières colonnes de la seconde ligne, et le troisième sera situé dans les deux premières colonnes de la dernière ligne. Exemple :\n\nlayout(mat = matrix(c(1,1,1,0,2,2,3,3,0),  3,  3,  byrow = TRUE))\n\nplot(x = log(1:10), y = 10:1, main = \"plot 1\")\n\nplot(x = exp(1:10), y = log(1:10), main = \"plot 2\")\n\nplot(x = sin(1:10), y = 1:10, main = \"plot 3\")"
  },
  {
    "objectID": "modules/graphique/Rbase_graph.html#représentation-uni-et-bivariée",
    "href": "modules/graphique/Rbase_graph.html#représentation-uni-et-bivariée",
    "title": "Graphique R-base",
    "section": "Représentation uni et bivariée",
    "text": "Représentation uni et bivariée\n\nVar. quantitative\n\n\nCode\n# gauche supérieur\nstripchart(mpg$displ, xlab = \"displ\", pch = 16)\n# droite supérieur\nstripchart(mpg$displ, xlab = \"displ\", method = \"stack\", pch = 16)\n# gauche inférieur\nstripchart(mpg$displ, xlab = \"displ\", method = \"jitter\", pch = 16)\n# droite inférieur\nstripchart(mpg$displ, ylab = \"displ\", method = \"jitter\", vertical = TRUE, pch = \"+\")\n\nplot(mpg$drv)   #---> barplot()\nbarplot(mpg$drv)\n\n# Pour la distribution\nhist(mpg$displ)\nhist(mpg$displ, freq = FALSE)\ndensity(mpg$displ)\n\n\n\n\n2 var. quantitatives\n\n\nCode\nplot(hwy ~ displ, data = mpg, pch = 16)\n\n\n\n\nVar. qualitative\n\n\n\n\n\n2 var. qualitatives\n\n\nCode\nplot()\nbarplot()\n\n\n\n\nQuali. vs Quanti.\n\n\nCode\nstripchart(hwy ~ trans, data = mpg, vertical = TRUE, pch = 16, metho = \"jitter\")\n\nboxplot(hwy ~ trans, data = mpg)\n\nplot()\n\nboxplot(hwy ~ trans, data = mpg)\nstripchart(hwy ~ trans, data = mpg, vertical = TRUE, pch = 16, metho = \"jitter\", add = TRUE)\n\nboxplot(hwy ~ trans + drv, data = mpg)"
  }
]